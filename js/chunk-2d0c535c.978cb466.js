(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0c535c"],{"3db7":function(e,t){var n="\n## Why?\n\n1. I'm still a novice at VueJS and I want to get more experience.\n2. I wanted to experiment with [Cocos Creator] and blog about the experience\n3. I didn't feel like using a pre-made solution since I know I can whip one up for myself.\n\n## Getting started\n\nFirst off, I already have Visual Studio Code setup with Node and have done a Vue project in the past week. \nSo I was easily able to start the project by opening up a new project and then in the terminal typing:\n\n    vue create .\n\nI then went through the motions of selecting what I wanted from the dialog, and then I forgot to pass it the flag to not generate the Hello World defaults. Oops. \nA few minutes later and I had ran my imports to get the vue-bootstrap and vue-router libraries included in my project because I'm lazy and don't like to style things.\nAfter I had made a Nav component, setup a couple of main \"view\" components to pass to the router I realized I didn't know how I was going to structure my posts.\n\n## How do I dynamically load data for a static site?\n\nI don't want to keep everything in one file, and I like having an organized file hierarchy if at all possible. So I knew I was going to dump some type of metadata or data file\nfor each one of these blog posts into a seperate file. This meant loading each of them individually by an id that corresponds to their filename. The routing was straightforward,\nin the vue-router documentation it talks about how to setup a dynamic route using `:` in the object like so\n\n    {\n      path: \"/dev-blog/:id\",\n      component: DevBlogPost,\n    }\n\nBut how does one load posts dynamically onto a page from vue? A little bit of reading further in the vue docs led me to the [reacting to params changes] page.\nThis section mentions that you can use the `this.$route` to get at the params, but still no hint since the people writing this docs probably assume we're using Ajax.\nI turned towards a web search and [found out] that you can just call `import` and resolve the promise to get back data from a JS file. So, about 10 seconds later I had\n\n    loadPageData(id) {\n      const pageDataImport = import (`../posts/${id}`)\n      const clone = this\n      pageDataImport.then((pageData) => {\n          clone.title = pageData.title\n          clone.summary = pageData.summary\n          clone.content = md.render(pageData.content)\n      })\n    }\n\nand then plugged it into the `beforeRouteUpdate` method as well as the `mounted` hook and I had a simple way to load data in. This was working from my local machine. But I did\ncurious if it was going to work once it was live. So I quickly fired off `npm run build` and waited for it to create the dist folder so I could pop it open. I ran into a problem\nwhen I forgot that I didn't have php or python installed on my Windows machine I was working on. So a quick search found me [this extension for chrome] that let me serve the files.\n\nIt worked. Which I guess shouldn't surprise me, but I guess I'm just so used to the JVM that an import command being ran on the fly like this just throws me for a loop.\n\n## DRY the meta data?\n\nAt this point I had started writing this blog post, creating a meta object in my main blog listing like this\n\n    data () {\n      return {\n        posts: [\n          {\n            id: 'making-the-blog',\n            title: 'Making the Blog',\n            summary: 'Using Vue JS to make a quick static site blogging platform for myself in a couple of hours.'\n          }\n        ]\n      }\n    }\n\nand also creating the file _posts/making-the-blog.js_ like this\n\n    module.exports = {\n      title: \"Making the blog\",\n      summary: \"About how I made this site with Vue\",\n      content: 'test'\n    };\n\nthis worked out and rendered as expected, but I was stuck wondering if there was a way I could avoid duplicating my efforts here. After about 5 minutes of thinking about it\nI came up with a solution that would work and only introduce one extra file into the mix. I commited my files to git in case I screwed things up, threw on [some hype music]\nand got to work. First, I added _posts/index.js_ and then moved my posts array from my component into it. I ran into weirdness and assumed it had something to do with the \nfile name, so I swapped it to meta.js and then found out that if you use `import` then you get a promise, but if you use `require` you get exactly what you have being\nexported from the file. Using require, I could now import the shared meta list in both my listing component, and use it in my post component to find and retrieve the meta\ndata for the post. Bam. DRY metadata for my files.\n\n    const postIndex = require('../posts/meta')\n    loadPageData(id) {\n      let meta = null\n      for (let index = 0; index < postIndex.length; index++) {\n        meta = postIndex[index];\n        if (meta.id === id) {\n          break;\n        }\n      }\n      \n      if (!meta) {\n        this.title = 'No Post Here'\n        this.summary = \"Looks like you've loaded a post that doesn't exist?\"\n        this.content = \"Try navigating back home and see if you can find your way back.\"\n        return\n      }\n\n      const pageContent = import (`../posts/${id}`)\n      \n      const clone = this\n      pageContent.then((pageData) => {\n          clone.title = meta.title\n          clone.summary = meta.summary\n          clone.content = md.render(pageData.content)\n      })\n    }\n\nThe `loadPage` method got longer but hey, at least I don't have to manage multiple title and summary elements.\n\n## What about rendering the page itself?\n\nMarkdown is my favorite way to write blog posts. I don't really care about flavor of markdown most of the time, so I grabbed the first one I could find\n\n    npm install markdown-it\n\nand then calling it is pretty easy:\n\n    const MarkdownIt = require('markdown-it')\n    const md = new MarkdownIt()\n    ...\n    md.render(pageData.content)\n\nmy only real concern at the moment is that I require the markdown and create a new instance of the markdownIt library within the component each time.\nIt's not really a concern because the vue router documentation says:\n\n> One thing to note when using routes with params is that when the user navigates from /user/foo to /user/bar, the same component instance will be reused.\n\nwhich means that the require probably only happens once. But if I _was_ more concerned or didn't know that, I would have probably written up a quick Vue plugin\nto make the markdownit global for use anywhere within Vue.\n\n### Publishing to github pages\n\nNow that the blog post is rendering, my next step besides adding some text and style to the non-blog pages is to get this thing somewhere where it can be read.\nLuckily, I recently did this at work and know that there's an npm package for publishing to github pages that was super easy to use.\n\n    npm install gh-pages\n\nThis library uses properties set in the _package.json_ file and some script commands to decide what's getting published where but it's really easy.\n\n    \"homepage\": \"https://edgecaseberg.github.io/dev-blog\",\n    ...\n    \"scripts\": {\n      ...\n      \"predeploy\" : \"npm run build\",\n      \"deploy\" : \"gh-pages -d dist\"\n      ...\n\nOnce that was done I could now run `npm run deploy` to push things up to github pages. Which was great besides the fact that I saw a white screen. After\ninspecting the page I realized the includes were trying to load from the root directory which is github.io, but I need it to load from the name of my repo\nsince github pages sites prefix the path wih the repository name. Luckily, a little bit of googling turned up the [publicPath option in Vue] and once I set\nthat, things started working as expected.\n\n### Automatically\n\nBut I'm far too lazy to remember to do that. It'd be better if I could just constantly push stuff up and call it a day so that my git push is my deploy.\nLiving dangerously I know, but when it comes to a personal blog I really don't care about that kind of QA cluttering up my stream of consciousness. So,\ngithub workflows can run commands for us, we just need to tell it to. Luckily, we don't need to reinvent the wheel here (though I tried first) since\n[someone already made a shared workflow anyone can use]. So, after some trial and error, I finally got this:\n\n    name: publish-gh-pages\n    on:\n      push:\n        branches:\n        - master\n    jobs:\n      deploy:\n        runs-on: ubuntu-latest\n        steps:\n        - uses: actions/checkout@v2\n        - uses: actions/setup-node@v2\n          with:\n            node-version: '14'\n            cache: 'npm'\n        - run: npm install\n        - run: npm run build\n        -\n          name: Deploy to GitHub Pages\n          uses: crazy-max/ghaction-github-pages@v2\n          with:\n            target_branch: gh-pages\n            build_dir: dist\n          env:\n            GITHUB_TOKEN: ${{ secrets.PUBLISHING_TOKEN }}\n\nEasy. Mind you, you have to remember to actually make the PAT in github and add it to your repository secrets. But with that in place I had a working site.\n\n## Wrapping up.\n\nAt this point my right eye started twitching and I realized that it was 2:47AM and I had started in on this project sometime around an hour ago when I had decided I wanted to blog \nabout my experiencing with Cocos creator. One thing led to another and instead of writing about Cocos I ended up writing about Vue and making a blog platform for myself. So, I'm off\nto bed but I hope that if you read this far you found out something useful. If you didn't by reading this blog, then maybe you could by [reading the code here].\n\nG'night.\n\n[Cocos Creator]:https://www.bookstack.cn/read/cocos-creator-3.3-en/5880ef9ce7a58296.md\n[reacting to params changes]:https://router.vuejs.org/guide/essentials/dynamic-matching.html#reacting-to-params-changes\n[found out]:https://vueschool.io/articles/vuejs-tutorials/lazy-loading-and-code-splitting-in-vue-js/\n[this extension for chrome]:https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb?hl=en\n[some hype music]:https://www.youtube.com/watch?v=vgASRm9Du7U\n[someone already made a shared workflow anyone can use]:https://github.com/crazy-max/ghaction-github-pages\n[reading the code here]:https://github.com/EdgeCaseBerg/dev-blog\n[publicPath option in Vue]:https://cli.vuejs.org/config/#publicpath\n";e.exports={content:n}}}]);
//# sourceMappingURL=chunk-2d0c535c.978cb466.js.map